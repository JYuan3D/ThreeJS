<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - instancing - raycast</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
	</head>
	<body>
		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "../build/three.module.js";

			import Stats from "./jsm/libs/stats.module.js";
			import { GUI } from "./jsm/libs/dat.gui.module.js";
			import { OrbitControls } from "./jsm/controls/OrbitControls.js";
			let camera, scene, renderer, controls, stats;

			let mesh;
			const amount = parseInt(window.location.search.substr(1)) || 10;
			const count = Math.pow(amount, 3);
			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2(1, 1);

			const color = new THREE.Color();
			const white = new THREE.Color().setHex( 0xffffff );

			init();
			animate();

			function init() {
				camera = new THREE.PerspectiveCamera(
					60,
					window.innerWidth / window.innerHeight,
					0.1,
					100
				);
				camera.position.set(amount, amount, amount);
				camera.lookAt(0, 0, 0);

				scene = new THREE.Scene();

				const light1 = new THREE.HemisphereLight(0xffffff, 0x000088);
				light1.position.set(-1, 1.5, 1);
				scene.add(light1);

				const light2 = new THREE.HemisphereLight(0xffffff, 0x880000, 0.5);
				light2.position.set(-1, -1.5, -1);
				scene.add(light2);

				const geometry = new THREE.IcosahedronGeometry(0.5, 3);
				const material = new THREE.MeshPhongMaterial();

				mesh = new THREE.InstancedMesh(geometry, material, count);

				let i = 0;
				const offset = (amount - 1) / 2;

				const matrix = new THREE.Matrix4();

				for (let x = 0; x < amount; x++) {
					for (let y = 0; y < amount; y++) {
						for (let z = 0; z < amount; z++) {
							matrix.setPosition(offset - x, offset - y, offset - z);

							mesh.setMatrixAt(i, matrix);
							mesh.setColorAt(i, color);

							i++;
						}
					}
				}

				scene.add(mesh);

				//

				const gui = new GUI();
				gui.add(mesh, "count", 0, count);

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

<<<<<<< HEAD
				new OrbitControls(camera, renderer.domElement);
=======
				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.enableZoom = false;
				controls.enablePan = false;
>>>>>>> f3a832e637c98a404c64dae8174625958455e038

				stats = new Stats();
				document.body.appendChild(stats.dom);

				window.addEventListener("resize", onWindowResize);
				document.addEventListener("mousemove", onMouseMove);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function onMouseMove(event) {
				event.preventDefault();

				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			}

			function animate() {
				requestAnimationFrame(animate);

<<<<<<< HEAD
				render();
			}

			function render() {
				// 通过摄像机和鼠标位置更新射线
				raycaster.setFromCamera(mouse, camera);
				// 计算物体和射线的焦点
				const intersection = raycaster.intersectObject(mesh);
=======
				controls.update();
>>>>>>> f3a832e637c98a404c64dae8174625958455e038

				if (intersection.length > 0) {
					const instanceId = intersection[0].instanceId;

<<<<<<< HEAD
					mesh.setColorAt(instanceId, color.setHex(Math.random() * 0xffffff));
					mesh.instanceColor.needsUpdate = true;
				}

				renderer.render(scene, camera);
=======
				if ( intersection.length > 0 ) {

					const instanceId = intersection[ 0 ].instanceId;

					mesh.getColorAt( instanceId, color );

					if ( color.equals( white ) ) {

						mesh.setColorAt( instanceId, color.setHex( Math.random() * 0xffffff ) );

						mesh.instanceColor.needsUpdate = true;

					}

				}

				render();
>>>>>>> f3a832e637c98a404c64dae8174625958455e038

				stats.update();
			}
<<<<<<< HEAD
=======

			function render() {

				renderer.render( scene, camera );

			}

>>>>>>> f3a832e637c98a404c64dae8174625958455e038
		</script>
	</body>
</html>
